#define UI_COLOR vec3(1,1,1)

//8x8 font 
#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); 
#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);
#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);
#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);
#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);
#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);
#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);
#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);
#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);
#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);
#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);
#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);
#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);
#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);
#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);
#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);
#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);
#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);
#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);
#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);
#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);
#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);
#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);
#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);
#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);
#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);

#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);
#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);
#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);
#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);
#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);
#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);
#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);
#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);
#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);
#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);
#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);
#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);
#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);
#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);
#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);
#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);
#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);
#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);
#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);
#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);
#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);
#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);
#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);
#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);
#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);
#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);

#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);
#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);
#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);
#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);
#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);
#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);
#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);
#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);
#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);
#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);
#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);
#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);
#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);
#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);

#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); 
#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;

#define SP text.z+=4.;
#define _ text.z+=4.;
#define NL text.z=0.; text.y-=9.0;

vec2 pixel;
vec4 text;//x y index result
float ui = 0.0;
vec4 result;    

float char(int b1, int b2, int b3, int b4){
  int bin; 
  vec2 p = pixel - text.xy - vec2(text.z, 0); 
  text.z += 9.0; 
  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;
  p = floor(8.0-p);    int c = int(p.y / 2.0);
  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}
  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;
  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);
}
void digit(float d){
    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4
    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        
}
void drawNumber(float val, float fractPrecision){  
    if(sign(val)==-1.0) MINUS //draw minus sign if needed
    val = abs(val);    
    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length
    // log10(val) = log(val)/2.302585    
    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point 
    val = floor(val); // strip the fractional part   
    float count = intCount + fractPrecision; //totla number of digits to print    
    if(count > 8.){ E R R O R return;} //show error if count > 8 
    float pw = pow(10., count-1.);
    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number
        if(count<i){ continue;} //skip unnecessary loops
        if(i-fractPrecision == 0.){STP} //draw decimal point        
        float d = floor(val/pw); //get one digit
        digit( d ); //draw digit
        val -= d*pw; pw /= 10.; //prepare for next iteration
    }
}


void newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}
void moveCursor(in vec2 o){text.xy = o; text.z=0.0;}
float outputText(){return text.w;}

float printFloat(float val, float prec, vec2 p, vec2 o){
    newText(p, o);  drawNumber(val, prec); return outputText();
}

float printVec2(vec2 val, float prec, vec2 p, vec2 o){ 
    newText(p, o);
    float str = 0.0;
    drawNumber(val.x, prec);
    _ COM _
    drawNumber(val.y, prec);    
    str += outputText();    
    return str;
}



// distance functions
float dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}
float dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}
float dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}
float dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}
float fillMask(float dist){return clamp(-dist, 0.0, 1.0);}


// read/write
vec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }
bool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    
void setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}

//slider
void drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  
    
    float gap = 5.;
    vec4 data = readPixel(vec2(id,1)); 
    
    //if first frame write default value
    if(data.g < 0.1){ 
        data = vec4(val,.4,0,1);
        setPixel(vec2(id,1), data);
    }    
    
    //draw bg
    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); 
    
    //if mouse over slider write new value
    if(dfBox(iMouse.xy,b)<=gap){
        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;
        data.r = distanceFromLeftEdege/ b.z;        
        //data.a=1.0;
        setPixel(vec2(id,1), data);
        
        b.w=35.0;
    }
    
    //draw sliding bar   
    if(ui >=0.6){
    	b.z *= data.r;
        ui = mix(ui, .8, fillMask(dfBox(p,b)));
    }
    
    //draw number    
    vec4 tmp = text;
    ui = mix(ui, 0., printFloat(data.r, 3., p, b.xy + vec2(8., 5.)));
    text = tmp;
    
}


vec4 bounds = vec4(30,220,140,18);
#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;


void mainImage( out vec4 fragColor, in vec2 fragCoord ){
    
    vec2 p = fragCoord.xy;
    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);
    newText(p,vec2(0)); //for labels
    
    //define sliders    
    EASYSLIDER(1,.4)  _F I R S T  
    EASYSLIDER(2,.15)  _S E C O N D      
    EASYSLIDER(3,.74)  _T H I R D   
    EASYSLIDER(4,.5)  _F O U R T H     
    EASYSLIDER(5,.12)  _F I F T H   
    EASYSLIDER(6,.4)  _S I X T H   
          
    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders
    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels
    
    
    fragColor=result;    
    
}